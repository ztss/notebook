1.cat txtname可以查看一个文件，在中间加空格可以依次查看每一个文件。这个操作会将文件中的
  内容打印到输出流中，我们可以使用>或者>>重定向，将这些流中的数据弄到另一个文件中，其中
  如果不存在另一个文件，那么就会新建一个文件，>会重写已有的文件，而>>则在已有的文件后面
  添加。即
  cat txt1name txt2name > newtextname or cat txt1name txt2name >> newtextname
2.ls -lrt 可以看到每一个文件建立的时间，并且按照从旧到新排序。r即reverse，t即time。
3.我们也可以使用如下语句将standard error信息打印到一个文件中，其中重定向符号为2>.
  ls -l existingtext noexistingtext > listingtext 2> errorinfotext
  当然也有2>>，逻辑与文件重定向符号一样。
4.有时候我们不希望将我们操作的信息打印在屏幕上，也不希望将输出的信息存入文件中，因为这样
  会很慢，所以我们可以将这些重定向到一个特殊的文件中/dev/null.所有的这些信息都会消失。
5.使用tail可以查看一个文件的尾部，也可以使用数字控制看最后几行
  tail -number textname 也可以使用 tail -f textname 持续不断的查看一个不断更新的文件
  的尾部。
6.标准输入重定向默认从键盘读入输入，也可以从一个文件中读入输入，如下
  program < inputfile > outfile
7.unix管道将一个程序的标准输出作为另一个程序的标准输入，这样可以节省计算的时间。因为可以
  不用再读磁盘。如下是一个使用grep的管道命令
  grep -v "regularexpression1" textname | \
  grep --color -i "regularexpression2"
  上面的管道命令第一行以文件作为标准输入，第一行处理后的结果作为第二个程序的标准输入。
  其中|为管道符号。grep命令的格式如下
  grep [options] regularexpressionpattern [file].
8.假设我们有两个程序，都会有standard error输出。我们需要用管道来运行两个程序，如下
  program1 inputfile.txt 2> stderr.txt | program2 2> stderr.txt > outputfile.txt
  这样我们可以分开的看两个程序error输出，而不会相互有干扰。
9.假设我们需要使用管道来用一个程序处理另一个程序的standard error和standard output。即
  一个程序的standard input为前一个程序的standard error和standard output。那么我们可
  以使用
  program1 inputfile.txt 2>&1 | grep "error"。2>&1即将两个输出结合在一起。
10.我们也可以使用tee命令将一个程序的输出重定向到文件中，这是这个输出的一个copy，所以我
   们还可以使用管道将输出作为另一个文件的输入。如下
   program1 inputfile.txt | tee interfile.txt | program2 > outputfile.txt。
11.通过在一条shell命令后面加&,我们可以将这个process运行在后台，而即使这个process没有完
   成,我们仍然可以使用shell。如
   program inputfile.txt > outfile.txt &
   然后使用jobs可以查看所有在后台运行的process，并且可以看到他们的id，然后使用fg加上id
   可以将一个后台放回前台运行。但是必须记住，虽然这些程序在后台运行，但是如果关掉我们的
   终端，那么这些程序就会终止。我们也可以将前台的程序转移到后台运行，使用crlt+z可以中断
   当前运行的前台程序，然后使用bg命令来移到后台运行。
12.程序运行完成后会有返回码，如果成功运行结束，那么这个status就是0，否则就是非0.我们可
   以利用这个还有&&或者||来实现条件运行。
13.unixshell有命令代换的功能
   echo "there are $(grep -c "^>" inputfile.txt)entries in my file."
   grep -c "^>" inputfile.txt 统计文件中有几行包含>。这就是命令代换。
   我们可以使用以下命令来创建文件，使得文件名字包含创建文件的时候的日期。
   mkdir results-$(date +%F)
14.如果有一些操作我们经常用到，那么我们可以给这些操作一些别名。如
   alias mkpr="mkdir -p {data/seqs,scripts,analysis}"
   那么我们只要使用别名就可以使用这些命令了，可以节省一点时间。use add alias to add
   it to your ~/.bashrc (or ~/.profile if on OS X).


Working with Remote Machines
15.我们可以使用ssh语句链接一个远程主机，在ssh后面加上需要链接主机的Ip地址就可以。
16.使用hostname命令可以看到主机名字，而使用whoami可以看到用户名字。
17.我们在shell上运行的语句（即我们的程序）随着我们把终端关闭就会被中止，这个时候我们可以
   通过在语句前面加上nohub就可以让我们的程序继续运行即使我们把终端关闭了，这个语句会返
   回一个processid,我们可以通过processid继续操作这个程序。如下
   nohub program1 > outfile.txt &
18.我们可以通过一个tmux命令建立一个新的会话。如下
   tmux new-session -s mysessionname -s让我们可以给我们的新session一个名字。然后按
   crlt+a+d可以退出这个session，回到我们本来的终端。然后使用
   tmux list-sessions可以列出所有建立的session的名字，使用
   tmux attach -t sessionname可以重新链接一个session。为什么我们要使用session呢，The
   most useful feature of Tmux (and terminal multiplexers in general) is the
   ability to detach and reattach sessions without losing our work。


Git for Scientists
19.我们应该使用git来管理我们的项目，来使得我们可以更好的合作工作。为了更好的使用git来合
   作工作，我们首先应该告诉git我们的名字和Email。
   git config --global user.name "yourname"
   git config --global user.email "youemail"
   也可以使用 git config --global color.ui true 来设置更方便我们使用的界面颜色。
20.如果我们想用git管理我们的项目，首先进入到这个项目的文件夹，然后使用
   git init 。然后这个文件夹下面就会生成一个.git文件。
   我们也可以从其他的地方克隆一个repo。使用以下语句就可以了
   git clone url
   这个时候你还不能直接改变你克隆的项目的原始版本。
21.在我们建立的repo文件夹下，我们先使用git status来查看下我们的repo的状态，可以看到未
   被track的文件以及我们当前所在的分支，然后可以使用
   git add filename 添加一个被track的文件。
22.
