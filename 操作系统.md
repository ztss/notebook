## 操作系统接口
1. 内核：一个向其他运行中程序提供服务的特殊程序。
2. 进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总
是在用户空间和内核空间之间交替运行。
3. 内核提供的一系列系统调用就是用户程序可见的操作系统接口。
   系统调用	描述
   fork()	创建进程
   exit()	结束当前进程
   wait()	等待子进程结束
   kill(pid)	结束 pid 所指进程
   getpid()	获得当前进程 pid
   sleep(n)	睡眠 n 秒
   exec(filename, * argv)	加载并执行一个文件
   sbrk(n)	为进程内存空间增加 n 字节
   open(filename, flags)	打开文件，flags 指定读/写模式
   read(fd, buf, n)	从文件中读 n 个字节到 buf
   write(fd, buf, n)	从 buf 中写 n 个字节到文件
   close(fd)	关闭打开的 fd
   dup(fd)	复制 fd
   pipe( p)	创建管道， 并把读和写的 fd 返回到p
   chdir(dirname)	改变当前目录
   mkdir(dirname)	创建新的目录
   mknod(name, major, minor)	创建设备文件
   fstat(fd)	返回文件信息
   link(f1, f2)	给 f1 创建一个新名字(f2)
   unlink(filename)	删除文件
4. xv6 shell 本质上是一个 Unix Bourne shell 的简单实现。它的实现在第 7850 行。
## 进程和内存
5. 一个 xv6 进程由两部分组成，一部分是用户内存空间（指令，数据，栈），另一部分是仅对内
核可见的进程状态。内核将每个进程和一个pid(process identifier)关联起来。
6. 一个进程可以通过系统调用 fork 来创建一个新的进程。fork 创建的新进程被称为子进程，子
进程的内存内容同创建它的进程（父进程）一样。fork 函数在父进程、子进程中都返回（一次调用
两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。父子进程拥有不同的内存空间
和寄存器，改变一个进程中的变量不会影响另一个进程。
```
int pid;
pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
上面调用fork()，创建一个子进程，然后对于父进程，返回的值为子进程的pid，所以父进程的pid
是大于0的。所以进入if(pid>0)，而对于子进程，从fork()的下一条开始执行，而且是与父进程独立
的，pid对于子进程返回0，所以进入else if(pid == 0)。接下来打印的内容只是看父子进程运行
的速度了，但是最后打印的一定是child is done。因为父进程中有一个wait()。
```
7. 系统调用 exec 将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进
程的内存空间。这份文件必须符合特定的格式，规定文件的哪一部分是指令，哪一部分是数据，哪里
是指令的开始等等。xv6 使用 ELF 文件格式，第2章将详细介绍它。当exec执行成功后，它并不返
回到原来的调用进程，而是从ELF头中声明的入口开始，执行从文件中加载的指令。exec 接受两个
参数：可执行文件名和一个字符串参数数组。举例来说：
```
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
这段代码将调用程序替换为 /bin/echo 这个程序，这个程序的参数列表为echo hello。大部分的
程序都忽略第一个参数，这个参数惯例上是程序的名字（此例是 echo）。
```
8. fork 和 exec 为什么没有被合并成一个调用，我们之后将会发现，将创建进程——加载程序分为
两个过程是一个非常机智的设计。
9. 一个进程在需要额外内存时可以通过调用 sbrk(n) 来增加 n 字节的数据内存。 sbrk 返回新
的内存的地址。xv6 没有用户这个概念当然更没有不同用户间的保护隔离措施。按照 Unix 的术语
来说，所有的 xv6 进程都以 root 用户执行。
10. shell 的主要结构很简单，详见 main 的代码（8001）。
## I/O和文件描述符
11. 文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象。文件描述符的接口是
对文件、管道、设备等的抽象，这种抽象使得它们看上去就是字节流。
12. 每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个
从0开始的文件描述符空间。按照惯例，进程从文件描述符0读入（标准输入），从文件描述符1输出
（标准输出），从文件描述符2输出错误（标准错误输出）。我们会看到 shell 正是利用了这种惯
例来实现 I/O 重定向。shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台
（console）的默认文件描述符。
13. read(fd, buf, n) 从 fd 读最多 n 个字节（fd 可能没有 n 个字节），将它们拷贝到 buf
中，然后返回读出的字节数。
14. write(fd, buf, n) 写 buf 中的 n 个字节到 fd 并且返回实际写出的字节数。如果返回值
小于 n 那么只可能是发生了错误。就像 read 一样，write 也从当前文件的偏移处开始写，在写
的过程中增加这个偏移。
15. 下面的程序是cat的本质实现:将数据从标准输入复制到标准输出
```
char buf[512];
int n;

for(;;){
	n = read(0, buf, sizeof buf);
	if(n == 0)
    	break;
    if(n < 0){
        fprintf(2, "read error\n");
		exit();
	}
    if(write(1, buf, n) != n){
    	fprintf(2, "write error\n");
        exit();
	}
}
```
16. 系统调用 close 会释放一个文件描述符，使得它未来可以被 open, pipe, dup 等调用重用。
一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。
17. 文件描述符和 fork 的交叉使用使得 I/O 重定向能够轻易实现。fork 会复制父进程的文件描
述符和内存，所以子进程和父进程的文件描述符一模一样。exec 会替换调用它的进程的内存但是会
保留它的文件描述符表。这种行为使得 shell 可以这样实现重定向：fork 一个进程，重新打开指
定文件的文件描述符，然后执行新的程序。下面是一个简化版的 shell 执行。所谓的I/O重定向也
就是让已创建的FD指向其他文件。
```
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
	close(0);
	open("input.txt", O_RDONLY);
    exec("cat", argv);
}
子进程关闭文件描述符0后，我们可以保证open 会使用0作为新打开的文件 input.txt的文件描述符
（因为0是 open 执行时的最小可用文件描述符）。之后 cat 就会在标准输入指向 input.txt 的
情况下运行。
```
xv6 的 shell 正是这样实现 I/O 重定位的（7930）。
18. fork 和 exec 是单独的两种系统调用这种区分使得 shell 可以在子进程执行指定程序之前对
子进程进行修改。
19. 虽然 fork 复制了文件描述符，但每一个文件当前的偏移仍然是在父子进程之间共享的，考虑
下面这个例子：
```
if(fork() == 0) {
	write(1, "hello ", 6);
	exit();
} else {
	wait();
	write(1, "world\n", 6);
}
所以输出应该是hello world，这种行为有利于顺序执行的 shell 命令的顺序输出，例如 (echo
hello; echo world)>output.txt。
```
20. dup 复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符。这两个描述
符共享一个文件偏移，正如被 fork 复制的文件描述符一样。这里有另一种打印 “hello world”
的办法：
```
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
从同一个原初文件描述符通过一系列 fork 和 dup 调用产生的文件描述符都共享同一个文件偏移
所以上面的代码也可以输出hello world。
```
21. 文件描述符是一个强大的抽象，因为他们将他们所连接的细节隐藏起来了：一个进程向描述符1
写出，它有可能是写到一份文件，一个设备（如控制台），或一个管道。
## 管道
22. 管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于
读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。
23. exec函数会取代执行它的进程,  也就是说, 一旦exec函数执行成功, 它就不会返回了, 进程
结束.但是如果exec函数执行失败, 它会返回失败的信息, 而且进程继续执行后面的代码!
24. dup(int oldfd)用来复制参数oldfd所指的文件描述词, 并将它返回. 此新的文件描述词和参
数oldfd指的是同一个文件, 共享所有的锁定、读写位置和各项权限或旗标。
25. 接下来的示例代码运行了程序 wc，它的标准输出绑定到了一个管道的读端口。
```
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
	close(0);
	dup(p[0]);//子进程将管道的读端口拷贝在描述符0上，因为描述符0已经被关闭了，所以管道的
  //读端口一定会绑定到0上。
	close(p[0]);
	close(p[1]);
	exec("/bin/wc", argv);
} else {
	write(p[1], "hello world\n", 12);
	close(p[0]);
	close(p[1]);
}
如果数据没有准备好，那么对管道执行的read会一直等待，直到有数据了或者其他绑定在这个管道
写端口的描述符都已经关闭了。在后一种情况中，read 会返回 0，就像是一份文件读到了最后。读
操作会一直阻塞直到不可能再有新数据到来了，这就是为什么我们在执行 wc 之前要关闭管道的写
端口。如果 wc 指向了一个管道的写端口，那么 wc 就永远看不到 eof 了。
```
26. xv6 shell 对管道的实现（比如 fork sh.c | wc -l）和上面的描述是类似的（7950行）。
子进程创建一个管道连接管道的左右两端。然后它为管道左右两端都调用 runcmd，然后通过两次
wait 等待左右两端结束。管道右端可能也是一个带有管道的指令，如 a | b | c, 它 fork 两个
新的子进程（一个 b 一个 c），因此，shell 可能创建出一颗进程树。树的叶子节点是命令，中间
节点是进程，它们会等待左子和右子执行结束。理论上，你可以让中间节点都运行在管道的左端，但
做的如此精确会使得实现变得复杂。
27. pipe可能看上去和临时文件没有什么两样，但管道和临时文件起码有三个关键的不同点。首先
，管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 /tmp/xyz。
第二，管道可以传输任意长度的数据。第三，管道允许同步：两个进程可以使用一对管道来进行二者
之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 write 完成数据的发送。
## 文件系统
28. 文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。xv6把目录实现为一种
特殊的文件。不从 / 开始的目录表示的是相对调用进程当前目录的目录，调用进程的当前目录可以
通过 chdir 这个系统调用进行改变。
29. 有很多的系统调用可以创建一个新的文件或者目录：mkdir 创建一个新的目录，open 加上
O_CREATE 标志打开一个新的文件，mknod 创建一个新的设备文件。下面这个例子说明了这3种调用：
```
mkdir("/dir");
fd=open("/dir/file",O_CREATE|O_WRONLY);
close(fd);
mknod("/console",1,1)
```
mknod 在文件系统中创建一个文件，但是这个文件没有任何内容。相反，这个文件的元信息标志它是
一个设备文件，并且记录主设备号和辅设备号（mknod 的两个参数），这两个设备号唯一确定一个
内核设备。当一个进程之后打开这个文件的时候，内核将读、写的系统调用转发到内核设备的实现上，
而不是传递给文件系统。
30. fstat可以获取一个文件描述符指向的文件的信息。它填充一个名为 stat 的结构体，它在
stat.h 中定义为：
```
#define T_DIR 1
#define T_FILE 2
#define T_DEV 3
//Directory
//File
//Device
     struct stat{
       short type;//type of file
       int dev;//file system's disk Device
       uint ino;//Inode number
       short nlink;//number of links to file
       uint size;//size of file in bytes
     };
```
文件名和这个文件本身是有很大的区别。同一个文件（称为 inode）可能有多个名字，称为连接
(links)。系统调用 link 创建另一个文件系统的名称，它指向同一个 inode。下面的代码创建了
一个既叫做 a 又叫做 b 的新文件。
```
open("a", O_CREATE|O_WRONGLY);
link("a", "b");
读写 a 就相当于读写 b。每一个 inode 都由一个唯一的 inode 号 直接确定。
```
系统调用 unlink 从文件系统移除一个文件名。
```
unlink("a");
一个文件的 inode 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件
再指向它。
```
31. xv6 关于文件系统的操作都被实现为用户程序，诸如 mkdir，ln，rm 等等。这种设计允许任
何人都可以通过用户命令拓展 shell 。有一个例外，那就是 cd，它是在 shell 中实现的（8016）。
cd 必须改变 shell 自身的当前工作目录。如果 cd 作为一个普通命令执行，那么 shell 就会
fork 一个子进程，而子进程会运行 cd，cd 只会改变子进程的当前工作目录。父进程的工作目录
保持原样。
## 现实情况
32. UNIX 将“标准”的文件描述符，管道，和便于操作它们的 shell 命令整合在一起，这是编写通
用、可重用程序的重大进步。


## 第一个进程
33. 进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供“看上去”私有
的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU。
34. 进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供“看上去”私有的
，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU。
35. xv6使用页表（由硬件实现）来为每个进程提供其独有的地址空间。页表将虚拟地址（x86 指
令所使用的地址）翻译（或说“映射”）为物理地址（处理器芯片向主存发送的地址）。一片地址空间
包含了从虚拟地址0开始的用户内存。它的地址最低处放置进程的指令，接下来则是全局变量，栈区，
以及一个用户可按需拓展的“堆”区（malloc 用）。
36. xv6 使用结构体 struct proc (2103) 来维护一个进程的众多状态。一个进程最为重要的状态
是进程的页表，内核栈，当前运行状态。我们接下来会用 p->xxx 来指代 proc 结构中的元素。
37. 每个进程都有一个运行线程（或简称为线程）来执行进程的指令。线程可以被暂时挂起，稍后
再恢复运行。系统在进程之间切换实际上就是挂起当前运行的线程，恢复另一个进程的线程。线程的
大多数状态（局部变量和函数调用的返回地址）都保存在线程的栈上。
38. 每个进程都有用户栈和内核栈（p->kstack）。当进程运行用户指令时，只有其用户栈被使用，
其内核栈则是空的。然而当进程（通过系统调用或中断）进入内核时，内核代码就在进程的内核栈中
执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程的线程交替地
使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户
栈，内核也能保持运行。当进程使用系统调用时，处理器转入内核栈中，提升硬件的特权级，然后运
行系统调用对应的内核代码。当系统调用完成时，又从内核空间回到用户空间：降低硬件特权级，转
入用户栈，恢复执行系统调用指令后面的那条用户指令。线程可以在内核中“阻塞”，等待 I/O, 在
I/O 结束后再恢复运行。
39. p->state 指示了进程的状态：新建、准备运行、运行、等待 I/O 或退出状态中。
40. p->pgdir 以 x86 硬件要求的格式保存了进程的页表。xv6 让分页硬件在进程运行时使用
p->pgdir。进程的页表还记录了保存进程内存的物理页的地址。
41. BIOS 存放在非易失存储器中，BIOS 的作用是在启动时进行硬件的准备工作，接着把控制权交
给操作系统。BIOS 会把控制权交给从引导扇区（用于引导的磁盘的第一个512字节的数据区）加载
的代码。引导扇区中包含引导加载器(boot loader)——负责内核加载到内存中。
42. 引导加载器的第一条指令 cli（8412）屏蔽处理器中断。引导加载器还没有允许分页硬件工作；
它通过分段硬件把逻辑地址转化为线性地址，然后直接作为物理地址使用。xv6 会配置分段硬件，使
之不对逻辑地址做任何改变，直接得到线性地址，所以线性地址和逻辑地址是相等的。由于历史原因
我们用虚拟地址这个术语来指程序操作时用的地址。xv6 的虚拟地址等于 X86 的逻辑地址，同样也
等于分段硬件映射的线性地址。等到开启了分页后，系统中值得关心的就只有从线性地址到物理地址
的映射。
43. BIOS 完成工作后，%ds, %es, %ss 的值是未知的，所以在屏蔽中断后，引导加载器的第一个
工作就是将 %ax 置零，然后把这个零值拷贝到三个段寄存器中（8415-8418）。
44. 当 PC 开机时，它会初始化自己然后从磁盘中载入 boot loader 到内存并运行。附录 B 介绍
了其具体细节。然后，boot loader 把 xv6 内核从磁盘中载入并从 entry（1040）开始运行。x86
的分页硬件在此时还没有开始工作；所以这时的虚拟地址是直接映射到物理地址上的。
45. boot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核
数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x10
0000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I/O 设备的。
46. 为了让内核的剩余部分能够运行，entry 的代码设置了页表，将 0x80000000（称为 KERNBASE
（0207））开始的虚拟地址映射到物理地址 0x0 处。注意，页表经常会这样把两段不同的虚拟内存
映射到相同的一段物理内存，我们将会看到更多类似的例子。
47. 在 main 初始化了一些设备和子系统后，它通过调用 userinit（1239）建立了第一个进程。
userinit 首先调用 allocproc(2205)。allocproc（2205）的工作是在页表中分配一个槽（即结
构体 struct proc），并初始化进程的状态，为其内核线程的运行做准备。注意一点：userinit
仅仅在创建第一个进程时被调用，而 allocproc 创建每个进程时都会被调用。allocproc 会在
proc 的表中找到一个标记为 UNUSED(2211-2213)的槽位。当它找到这样一个未被使用的槽位后，
allocproc 将其状态设置为 EMBRYO，使其被标记为被使用的并给这个进程一个独有的 pid（2201
-2219）。接下来，它尝试为进程的内核线程分配内核栈。如果分配失败了，allocproc 会把这个槽
位的状态恢复为 UNUSED 并返回0以标记失败。
48. 我们将会在第3章看到，将控制权从用户转到内核是通过中断机制实现的，中断具体地说是系统
调用、中断和异常。每当进程运行中要将控制权交给内核时，硬件和 xv6 的 trap entry 代码就会
在进程的内核栈上保存用户寄存器。userinit 把值写在新建的栈的顶部，使之就像进程是通过中断
进入内核的一样（2264-2270）。所以用于从内核返回到用户代码的通用代码也就能适用于第一个进
程。这些保存的值就构成了一个结构体 struct trapframe，其中保存的是用户寄存器。现在如图
表1-3所示，进程的内核栈已经完全准备好了。
49. 第一个进程会先运行一个小程序（initcode.S（7700）），于是进程需要找到物理内存来保存
这段程序。程序不仅需要被拷贝到内存中，还需要页表来指向那段内存。
50. 大多操作系统都采用了进程这个概念，而大多的进程都和 xv6 的进程类似。但是真正的操作系
统会利用一个显式的链表在常数时间内找到空闲的 proc，而不像 allocproc 中那样花费线性时间；
xv6 使用的是朴素的线性搜索（找第一个空闲的 proc）。


## 页表
51. 页表使得 xv6 能够让不同进程各自的地址空间映射到相同的物理内存上，还能够为不同进程的
内存提供保护。 xv6 主要利用页表来区分多个地址空间，保护内存。另外，它也使用了一些简单的
技巧，即把不同地址空间的多段内存映射到同一段物理内存（内核部分）
52. 回顾一下，x86 的指令（用户和内核均是如此）计算的都是虚拟地址。机器的 RAM，或者物理
内存，则是用物理地址来作标记的。x86 的页表硬件通过映射机制将虚拟地址和物理地址联系起来。
53. 一个 x86 页表就是一个包含 2^20（1,048,576）条页表条目（PTEs）的数组。其中每一个条
目为32位。20位是物理页号(physical page number)，12位为标记位。标记位说明分页硬件对应
的虚拟地址的使用权限。
54. 物理内存是指 DRAM 中的储存单元。每个字节的物理内存都有一个地址，称为物理地址。而虚
拟地址则是程序所使用的。分页硬件会将程序发出的虚拟地址翻译为物理地址，然后发送给 DRAM
硬件以读写存储器。
55. 每个进程都有自己的页表，xv6 会在进程切换时通知分页硬件切换页表。
56. 一个4G虚拟地址空间，将会产生1024*1024个页，页表的每一项存储一个页(虚拟地址)和一个框
(物理地址)的映射，所以，至少需要1M个页表项。如果一个页表项大小为1Byte，则至少需要1M的空
间，所以页表被放在物理内存中，由操作系统维护。
57. CPU中有一个页表寄存器，里面存放着当前进程页表的起始地址和页表长度。将上述计算的页表
号和页表长度进行对比，确认在页表范围内，然后将页表号和页表项长度相乘，得到目标页相对于页
表基地址的偏移量，最后加上页表基地址偏移量就可以访问到相对应的框了，CPU拿到框的起始地址
之后，再把页内偏移地址加上，访问到最终的目标地址。
58. 每个进程的页表同时包括用户内存和内核内存的映射，这样当用户通过中断或者系统调用转入内
核时就不需要进行页表的转换了。大多数情况下，内核都没有自己的页表，所以内核几乎都是在借用
用户进程的页表。


## 陷入，中断和驱动程序
1. 运行进程时，cpu 一直处于一个大循环中：取指，更新 PC，执行，取指……。但有些情况下用户
程序需要进入内核，而不是执行下一条用户指令。这些情况包括设备信号的发出、用户程序的非法操
作。
2. 所有的中断都由内核管理，而不是进程。
3. 这一章交替使用陷入和中断这两个术语，但一定要记住陷入是由在 cpu 上运行的当前进程导致的
，而中断是由设备导致的，可能与当前进程毫无关系。
4. 在 x86 中，中断处理程序的入口在中断描述符表（IDT）中被定义。一个程序要在x86系统上进行
一个系统调用，它需要调用int n指令，这里n就是IDT的索引。
5. 驱动程序是操作系统用于管理某个设备的代码，它提供设备相关的中断处理程序。


## 锁
1. 我们通常使用锁来避免竞争。锁提供互斥。当我们说锁保护了数据时，是指锁保护了数据对应的
一组不变量（invariant）。不变量是数据结构在操作中维护的一些状态。
2. xv6 用结构体 struct spinlock（1401）。该结构体中的关键成员是 locked 。这是一个字，
在锁可以被获得时值为0，而当锁已经被获得时值为非零。逻辑上讲，xv6 应该用下面的代码来获得锁：
```
//获得锁
void acquire(struct spinlock* lk){
  for(;;){
    if(!lk->locked){
      lk->locked = 1;
      break;
    }
  }
}
```
段代码在现代处理器上并不能保证互斥。有可能两个（或多个）CPU 接连执行到第25行，发现
lk->locked 为0，然后都执行第26、27行拿到了锁。这时，两个不同的 CPU 持有锁，违反了互斥。
因为这段代码本身就存在竞争。如果想要保证代码的正确性，应该让25，26行成为原字操作。可以
使用xchg指令使这两行变为原字操作
```
while(xchg(&lk->locked,1)!=0)
   ;
xchg会讲第二个参数的值赋予第一个参数的指针，然后返回第一个参数所指的原来的数。
如果acquire已经获得了锁，那么lk->locked已经是1了，xchg会把1赋予locked，而且返回locked
原来的1值。继续while循环。而如果lk->locked为0，那么进入while循环的时候，xchg会把1赋予
lk->locked，代表已经获得锁了，而由于xchg返回的是locked原来的值，即返回0，所以循环结束。
由于xchg是原字操作，如果两个cpu同时运行到while，那么只有一个cpu能够进入。这样就避免了
竞争。
```
3. 由于没有理想、透明的解决方法，我们不得不在函数的使用规范中加入锁。编程者必须保证一个
函数不会在持有锁时调用另一个需要获得该锁的函数 f。就这样，锁也成为了我们的抽象中的一员。
4. 使用锁的基本原则，首先，当一个 CPU 正在写一个变量，而同时另一个 CPU 可能读/写该变量
时，需要用锁防止两个操作重叠。第二，当用锁保护不变量时，如果不变量涉及到多个数据结构，通
常所有这些数据结构需要作为整体用单个锁保护起来，这样才能维持不变量。
5. 锁会降低并发度，所以我们一定要避免过量的使用锁。
6. 调用者必须以固定顺序调用函数，这样函数才能以相同顺序获得锁。如果一段代码要使用多个锁，
那么必须要注意代码每次运行都要以相同的顺序获得锁，否则就有死锁的危险。例如文件系统在删除
一个文件时必须持有该文件及其所在文件夹的锁。xv6 总是首先获得文件夹的锁，然后再获得文件的
锁。
7. 为了避免在中断处理程序中出现循环死锁，当中断处理程序使用某个锁时，处理器就不能在允许
中断状态的时候持有锁。
8. 在本章中，我们都假设处理器会按照代码中的顺序执行指令。但是许多处理器会通过指令乱序来
提升性能。例如，如果一个指令需要多个周期完成，处理器会希望这条指令尽快执行，从而可以与其
他指令交叠，避免延误太久。例如，处理器会发现a,b指令序列之间没有关系，所以在a指令执行之前
执行b可以让两个指令同时完成。


## 调度
1. 通常我们对进程造成一个自己独占处理器的假象，然后让操作系统的多路复用机制（multiplex
）将单独的一个物理处理器模拟为多个虚拟处理器.
2. 实现多路复用有难点。如何从运行的一个进程切换到另一个进程，如何让上下文切换透明化，同
时切换进程的时候，如何避免竞争，释放资源的时候不能由该进程本身释放其资源。
3. 在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实
质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存
储在进程的私有堆栈中的。
4. 锁的机制使得 CPU 之间，进程之间不会互相打扰；调度使得进程可以共享 CPU。睡眠和唤醒实
际上是进程间通信的机制。下面我们讲解一个程序，它允许一个进程将一个非0指针发送给另一个进
程。
```
struct q{
  void* ptr;
};

void* send(struct q* q,void* p){
  while(q->ptr!=0){
    ;
  }
  q->ptr=p;
}

void* recv(struct q* q){
  void* p;
  while((p=q->ptr)==0){
    ;
  }
  q->ptr=0;
  return p;
}
上面这个程序其实是讲的有一个共享的队列，两个进程可以通过这个队列来发送接受信息。
对于send函数，只有当队列为空的时候，一个进程才通过这个函数将p发送到队列中。
而对于recv函数，只有当队列非空的时候，另一个进程才能通过recv函数从队列中读出一个指针，
然后接受。
上面的方法有一个缺陷就是如果a进程迟迟的不发送数据，那么b进程所在的cpu就会不停的浪费时间
在while循环中。所以这里我们需要一个通信方式，当send放入指针时，通知接收者。那么接收者进
程在等待的时间它所在的cpu就可以做其他事情了。
```
让我们来考虑一对调用 sleep 和 wakeup，其工作方式如下。sleep(chan) 让进程在任意的
chan 上休眠，称之为等待队列（wait channel）。sleep 让调用进程休眠，释放所占
CPU。wakeup(chan) 则唤醒在 chan 上休眠的所有进程，让他们的 sleep 调用返回。如果没有进
程在 chan 上等待唤醒，wakeup 就什么也不做。我们可以用这两个函数来重写我们上面的代码
```
struct q{
  void* ptr;
};

void* send(struct q* q,void* p){
  while(q->ptr!=0){
    ;
  }
  q->ptr=p;
  wakeup(q);
}

void* recv(struct q* q){
  void* p;
  while((p=q->ptr)==0){
    sleep(q);
  }
  q->ptr=0;
  return p;
}
这样就能充分的利用接收者进程所在的cpu的空间了。
但是这样写还是可能造成死锁，比如说recv在调用sleep之前，它所在的cpu收到了一个中断，然后
延迟了对sleep的调用，这个时候另一个进程送入了一个数据进入队列，然后另一个进程调用wakeup
，但是发现没有进程在休眠，所以就什么都不做。接着，recv 继续执行了：它调用 sleep 进入休
眠。这就出现问题了，休眠的 recv 实际上在等待一个已经到达的指针。而下一个 send 又在睡眠
中等着 recv 取出队列中的指针。
```
上面的情况在于send在错误的时机发生了。改正这个问题的代码如下
```
struct q{
  struct spinlock lock;
  void* ptr;
};

void* send(struct q* q,void* p){
  acquire(&q->lock);
  while(q->ptr!=0){
    ;
  }
  q->ptr=p;
  wakeup(q);
  release(&q->lock);
}

void* recv(struct q* q){
  void* p;
  acquire(&q->lock);
  while((p=q->ptr)==0){
    sleep(q);
  }
  q->ptr=0;
  release(&q->lock);
  return p;
}
上面的代码对q队列加上一个锁，防止send在错误的时机发生，这个代码仍然可能带来死锁，当recv
持有锁，然后进入sleep的时候，这个时候send就永远获得不了锁了。
```
要解决这个问题。必须改变sleep的接口，sleep要将锁作为一个参数，在进入睡眠状态后把锁释放。
而且，一旦进程被唤醒了，sleep在返回之前要重新获得锁。
```
struct q{
  struct spinlock lock;
  void* ptr;
};

void* send(struct q* q,void* p){
  acquire(&q->lock);
  while(q->ptr!=0){
    ;
  }
  q->ptr=p;
  wakeup(q);
  release(&q->lock);
}

void* recv(struct q* q){
  void* p;
  acquire(&q->lock);
  while((p=q->ptr)==0){
    sleep(q,&q->lock);
  }
  q->ptr=0;
  release(&q->lock);
  return p;
}
我们希望 sleep 能用原子操作释放 q->lock 并让接收进程进入休眠状态。
```
完整的发送者/接收者的实现还应该让发送者在等待接收者拿出前一个 send 放入的值时处于休眠状
态。
5. 接下来让我们看看 xv6 中 sleep 和 wakeup 的实现。总体思路是希望 sleep 将当前进程转
化为 SLEEPING 状态并调用 sched 以释放 CPU，而 wakeup 则寻找一个睡眠状态的进程并把它标
记为 RUNNABLE。



## 文件系统
1. 文件系统需要磁盘上数据结构来表示目录树和文件，文件系统必须支持崩溃恢复，不同的进程可
能同时操作文件系统，访问磁盘比访问内存要慢几个数量级，所以文件系统必须要维护一个内存内
的 cache 用于缓存常被访问的块。
2. 块缓冲层：同步对磁盘的访问，使得对于每一个块，同一时间只有一份拷贝放在内存中并且只有
一个内核线程使用这份拷贝；缓存常用的块以提升性能。置换策略是LRU。
