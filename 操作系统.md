## 操作系统接口
1. 内核：一个向其他运行中程序提供服务的特殊程序。
2. 进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总
是在用户空间和内核空间之间交替运行。
3. 内核提供的一系列系统调用就是用户程序可见的操作系统接口。
   系统调用	描述
   fork()	创建进程
   exit()	结束当前进程
   wait()	等待子进程结束
   kill(pid)	结束 pid 所指进程
   getpid()	获得当前进程 pid
   sleep(n)	睡眠 n 秒
   exec(filename, * argv)	加载并执行一个文件
   sbrk(n)	为进程内存空间增加 n 字节
   open(filename, flags)	打开文件，flags 指定读/写模式
   read(fd, buf, n)	从文件中读 n 个字节到 buf
   write(fd, buf, n)	从 buf 中写 n 个字节到文件
   close(fd)	关闭打开的 fd
   dup(fd)	复制 fd
   pipe( p)	创建管道， 并把读和写的 fd 返回到p
   chdir(dirname)	改变当前目录
   mkdir(dirname)	创建新的目录
   mknod(name, major, minor)	创建设备文件
   fstat(fd)	返回文件信息
   link(f1, f2)	给 f1 创建一个新名字(f2)
   unlink(filename)	删除文件
4. xv6 shell 本质上是一个 Unix Bourne shell 的简单实现。它的实现在第 7850 行。
## 进程和内存
5. 一个 xv6 进程由两部分组成，一部分是用户内存空间（指令，数据，栈），另一部分是仅对内
核可见的进程状态。内核将每个进程和一个pid(process identifier)关联起来。
6. 一个进程可以通过系统调用 fork 来创建一个新的进程。fork 创建的新进程被称为子进程，子
进程的内存内容同创建它的进程（父进程）一样。fork 函数在父进程、子进程中都返回（一次调用
两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。父子进程拥有不同的内存空间
和寄存器，改变一个进程中的变量不会影响另一个进程。
```
int pid;
pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
上面调用fork()，创建一个子进程，然后对于父进程，返回的值为子进程的pid，所以父进程的pid
是大于0的。所以进入if(pid>0)，而对于子进程，从fork()的下一条开始执行，而且是与父进程独立
的，pid对于子进程返回0，所以进入else if(pid == 0)。接下来打印的内容只是看父子进程运行
的速度了，但是最后打印的一定是child is done。因为父进程中有一个wait()。
```
7. 系统调用 exec 将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进
程的内存空间。这份文件必须符合特定的格式，规定文件的哪一部分是指令，哪一部分是数据，哪里
是指令的开始等等。xv6 使用 ELF 文件格式，第2章将详细介绍它。当exec执行成功后，它并不返
回到原来的调用进程，而是从ELF头中声明的入口开始，执行从文件中加载的指令。exec 接受两个
参数：可执行文件名和一个字符串参数数组。举例来说：
```
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
这段代码将调用程序替换为 /bin/echo 这个程序，这个程序的参数列表为echo hello。大部分的
程序都忽略第一个参数，这个参数惯例上是程序的名字（此例是 echo）。
```
8. fork 和 exec 为什么没有被合并成一个调用，我们之后将会发现，将创建进程——加载程序分为
两个过程是一个非常机智的设计。
9. 一个进程在需要额外内存时可以通过调用 sbrk(n) 来增加 n 字节的数据内存。 sbrk 返回新
的内存的地址。xv6 没有用户这个概念当然更没有不同用户间的保护隔离措施。按照 Unix 的术语
来说，所有的 xv6 进程都以 root 用户执行。
10. shell 的主要结构很简单，详见 main 的代码（8001）。
## I/O和文件描述符
11. 文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象。文件描述符的接口是
对文件、管道、设备等的抽象，这种抽象使得它们看上去就是字节流。
12. 每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个
从0开始的文件描述符空间。按照惯例，进程从文件描述符0读入（标准输入），从文件描述符1输出
（标准输出），从文件描述符2输出错误（标准错误输出）。我们会看到 shell 正是利用了这种惯
例来实现 I/O 重定向。shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台
（console）的默认文件描述符。
13. read(fd, buf, n) 从 fd 读最多 n 个字节（fd 可能没有 n 个字节），将它们拷贝到 buf
中，然后返回读出的字节数。
14. write(fd, buf, n) 写 buf 中的 n 个字节到 fd 并且返回实际写出的字节数。如果返回值
小于 n 那么只可能是发生了错误。就像 read 一样，write 也从当前文件的偏移处开始写，在写
的过程中增加这个偏移。
15. 下面的程序是cat的本质实现:将数据从标准输入复制到标准输出
```
char buf[512];
int n;

for(;;){
	n = read(0, buf, sizeof buf);
	if(n == 0)
    	break;
    if(n < 0){
        fprintf(2, "read error\n");
		exit();
	}
    if(write(1, buf, n) != n){
    	fprintf(2, "write error\n");
        exit();
	}
}
```
16. 系统调用 close 会释放一个文件描述符，使得它未来可以被 open, pipe, dup 等调用重用。
一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。
17. 文件描述符和 fork 的交叉使用使得 I/O 重定向能够轻易实现。fork 会复制父进程的文件描
述符和内存，所以子进程和父进程的文件描述符一模一样。exec 会替换调用它的进程的内存但是会
保留它的文件描述符表。这种行为使得 shell 可以这样实现重定向：fork 一个进程，重新打开指
定文件的文件描述符，然后执行新的程序。下面是一个简化版的 shell 执行。所谓的I/O重定向也
就是让已创建的FD指向其他文件。
```
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
	close(0);
	open("input.txt", O_RDONLY);
    exec("cat", argv);
}
子进程关闭文件描述符0后，我们可以保证open 会使用0作为新打开的文件 input.txt的文件描述符
（因为0是 open 执行时的最小可用文件描述符）。之后 cat 就会在标准输入指向 input.txt 的
情况下运行。
```
xv6 的 shell 正是这样实现 I/O 重定位的（7930）。
18. fork 和 exec 是单独的两种系统调用这种区分使得 shell 可以在子进程执行指定程序之前对
子进程进行修改。
19. 虽然 fork 复制了文件描述符，但每一个文件当前的偏移仍然是在父子进程之间共享的，考虑
下面这个例子：
```
if(fork() == 0) {
	write(1, "hello ", 6);
	exit();
} else {
	wait();
	write(1, "world\n", 6);
}
所以输出应该是hello world，这种行为有利于顺序执行的 shell 命令的顺序输出，例如 (echo
hello; echo world)>output.txt。
```
20. dup 复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符。这两个描述
符共享一个文件偏移，正如被 fork 复制的文件描述符一样。这里有另一种打印 “hello world”
的办法：
```
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
从同一个原初文件描述符通过一系列 fork 和 dup 调用产生的文件描述符都共享同一个文件偏移
所以上面的代码也可以输出hello world。
```
21. 文件描述符是一个强大的抽象，因为他们将他们所连接的细节隐藏起来了：一个进程向描述符1
写出，它有可能是写到一份文件，一个设备（如控制台），或一个管道。
## 管道
22. 管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于
读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。
23. exec函数会取代执行它的进程,  也就是说, 一旦exec函数执行成功, 它就不会返回了, 进程
结束.但是如果exec函数执行失败, 它会返回失败的信息, 而且进程继续执行后面的代码!
24. dup(int oldfd)用来复制参数oldfd所指的文件描述词, 并将它返回. 此新的文件描述词和参
数oldfd指的是同一个文件, 共享所有的锁定、读写位置和各项权限或旗标。
25. 接下来的示例代码运行了程序 wc，它的标准输出绑定到了一个管道的读端口。
```
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
	close(0);
	dup(p[0]);//子进程将管道的读端口拷贝在描述符0上，因为描述符0已经被关闭了，所以管道的
  //读端口一定会绑定到0上。
	close(p[0]);
	close(p[1]);
	exec("/bin/wc", argv);
} else {
	write(p[1], "hello world\n", 12);
	close(p[0]);
	close(p[1]);
}
如果数据没有准备好，那么对管道执行的read会一直等待，直到有数据了或者其他绑定在这个管道
写端口的描述符都已经关闭了。在后一种情况中，read 会返回 0，就像是一份文件读到了最后。读
操作会一直阻塞直到不可能再有新数据到来了，这就是为什么我们在执行 wc 之前要关闭管道的写
端口。如果 wc 指向了一个管道的写端口，那么 wc 就永远看不到 eof 了。
```
26. xv6 shell 对管道的实现（比如 fork sh.c | wc -l）和上面的描述是类似的（7950行）。
子进程创建一个管道连接管道的左右两端。然后它为管道左右两端都调用 runcmd，然后通过两次
wait 等待左右两端结束。管道右端可能也是一个带有管道的指令，如 a | b | c, 它 fork 两个
新的子进程（一个 b 一个 c），因此，shell 可能创建出一颗进程树。树的叶子节点是命令，中间
节点是进程，它们会等待左子和右子执行结束。理论上，你可以让中间节点都运行在管道的左端，但
做的如此精确会使得实现变得复杂。
27. pipe 可能看上去和临时文件没有什么两样，但管道和临时文件起码有三个关键的不同点。首先
，管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 /tmp/xyz。
第二，管道可以传输任意长度的数据。第三，管道允许同步：两个进程可以使用一对管道来进行二者
之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 write 完成数据的发送。
## 文件系统
28.
