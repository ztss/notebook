## 网络编程和套接字
1. 创建一个套接字
   ```
   int socket(int domain,int type,int protocol);
   ```
2. 创建套接字分配地址信息(ip地址和端口号)
   ```
   int  bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
   ```
3. 将套接字转化为可接受连接的状态
   ```
   int listen(int sockfd,int backlog);
   ```
4. 如果有人为了完成数据传输而请求连接
   ```
   int accept(int sockfd,struct sockaddr* addr,socklen_t* addrlen);
   ```
5. 即分为四步：调用socket函数创建套接字，调用bind函数分配ip地址和端口号，调用listen
   函数转为可接受请求状态，调用accept函数受理连接请求。
## 基于Linux的文件操作
1. 在Linux上，socket被认为是文件的一种
2. 文件描述符：是系统自动分配给文件或者套接字的整数，只是一个为了称呼的方便取得别名，
在Windows中被称为句柄。   

    | 文件描述符 | 对象 |
    |- |- |
    | 0| standard input|
    | 1| standard output|
    | 2| Standard error |
3. Linux上的文件或者套接字操作
   ```
   打开文件
   int open(const char* path,int flag);
   flag为文件打开的模式即读写或者文件操作模式
   关闭文件或者套接字
   int close(int fd);
   将数据写入文件或者传递数据
   ssize_t write(int fd,const void* buf,size_t nbytes);
   读取文件中数据或者接受数据
   ssize_t read(int fd,void* buf,size_t nbytes);
   ssize_t = signed int, size_t = unsigned int，其实它们都是通过typedef声明的基本数
   据类型取的别名而已。
   为什么要取别名呢？因为过去是16位系统，int是16位的，根据时代的变化，基本数据类型的形
   式也会变化。取了别名以后，以后修改的话，只需要修改typedef声明即可，可以减少代码改动
   ```
## 基于Windows平台的实现
1. Windows套接字大部分是参考BSD系列UNIX套接字设计的，所以很多地方都跟Linux套接字类似。
因此，只需要更改Linux环境下编好的一部分网络程序内容，就能再Windows平台下运行。大多数服
务器端都是在Linux系列的操作系统中开发的，而客服端则是在Windows平台上开发的。
2.
   ```
   Winsock数据传输函数
   int send(SOCKET s,const char* buf,int len,int flags);
   winsock数据接受函数
   int recv(SOCKET s,const char* buf,int len,int flags);
   ```
3. Windows与Linux上的套接字再一个区别是：Windows上需要先对Winsock库进行初始化，最后退
出还要注销Winsock相关库。
   ```
   int main(int  argc, char *argv[])
   {
      WSADATA wsaData;
      ...
      if(WSAStartup(MAKEWORD(1,2), &wsaData) != 0)
          ErrorHandling("WSAStartup() error!");
      ...
      return 0;
   }
   退出的时候需要释放Winsock库
   int WSACleanup(void);//返回0成功
   ```
## 习题
1.底层文件IO函数与ANSI标准定义的文件IO函数有什么区别
  通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，
  坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。
  先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。
  文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和
  管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。
2. 利用底层文件IO编写文件复制程序
```
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>
#define BUF_SIZE 100

void error_handling(char* message);

int main(void)
{
    char buf[BUF_SIZE];
    int fd=open("data.txt",O_RDONLY);
    if(fd==-1){
        error_handling("open() error!");
    }
    if(read(fd,buf,sizeof(buf))==-1)
        error_handling("read() error!");
    printf("file data: %s",buf);
    int fd1=open("data_copy.txt",O_CREAT|O_RDONLY|O_WRONLY|O_TRUNC);
    if(fd1==-1)
        error_handling("copy() error!");
    if(write(fd1,buf,sizeof(buf))==-1)
        error_handling("write() error!");
    close(fd);
    close(fd1);
    return 0;
}

void error_handling(char* message)
{
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
