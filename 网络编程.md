## 网络编程和套接字
1. 创建一个套接字
   ```
   int socket(int domain,int type,int protocol);
   ```
2. 创建套接字分配地址信息(ip地址和端口号)
   ```
   int  bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
   ```
3. 将套接字转化为可接受连接的状态
   ```
   int listen(int sockfd,int backlog);
   ```
4. 如果有人为了完成数据传输而请求连接
   ```
   int accept(int sockfd,struct sockaddr* addr,socklen_t* addrlen);
   ```
5. 即分为四步：调用socket函数创建套接字，调用bind函数分配ip地址和端口号，调用listen
   函数转为可接受请求状态，调用accept函数受理连接请求。
## 基于Linux的文件操作
1. 在Linux上，socket被认为是文件的一种
2. 文件描述符：是系统自动分配给文件或者套接字的整数，只是一个为了称呼的方便取得别名，
在Windows中被称为句柄。   

    | 文件描述符 | 对象 |
    |- |- |
    | 0| standard input|
    | 1| standard output|
    | 2| Standard error |
3. Linux上的文件或者套接字操作
   ```
   打开文件
   int open(const char* path,int flag);
   flag为文件打开的模式即读写或者文件操作模式
   关闭文件或者套接字
   int close(int fd);
   将数据写入文件或者传递数据
   ssize_t write(int fd,const void* buf,size_t nbytes);
   读取文件中数据或者接受数据
   ssize_t read(int fd,void* buf,size_t nbytes);
   ssize_t = signed int, size_t = unsigned int，其实它们都是通过typedef声明的基本数
   据类型取的别名而已。
   为什么要取别名呢？因为过去是16位系统，int是16位的，根据时代的变化，基本数据类型的形
   式也会变化。取了别名以后，以后修改的话，只需要修改typedef声明即可，可以减少代码改动
   ```
## 基于Windows平台的实现
1. Windows套接字大部分是参考BSD系列UNIX套接字设计的，所以很多地方都跟Linux套接字类似。
因此，只需要更改Linux环境下编好的一部分网络程序内容，就能再Windows平台下运行。大多数服
务器端都是在Linux系列的操作系统中开发的，而客服端则是在Windows平台上开发的。
2.
   ```
   Winsock数据传输函数
   int send(SOCKET s,const char* buf,int len,int flags);
   winsock数据接受函数
   int recv(SOCKET s,const char* buf,int len,int flags);
   ```
3. Windows与Linux上的套接字再一个区别是：Windows上需要先对Winsock库进行初始化，最后退
出还要注销Winsock相关库。
   ```
   int main(int  argc, char *argv[])
   {
      WSADATA wsaData;
      ...
      if(WSAStartup(MAKEWORD(1,2), &wsaData) != 0)
          ErrorHandling("WSAStartup() error!");
      ...
      return 0;
   }
   退出的时候需要释放Winsock库
   int WSACleanup(void);//返回0成功
   ```
## 习题
1.底层文件IO函数与ANSI标准定义的文件IO函数有什么区别
  通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，
  坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。
  先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。
  文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和
  管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。
2. 利用底层文件IO编写文件复制程序
```
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>
#define BUF_SIZE 100

void error_handling(char* message);

int main(void)
{
    char buf[BUF_SIZE];
    int fd=open("data.txt",O_RDONLY);
    if(fd==-1){
        error_handling("open() error!");
    }
    if(read(fd,buf,sizeof(buf))==-1)
        error_handling("read() error!");
    printf("file data: %s",buf);
    int fd1=open("data_copy.txt",O_CREAT|O_RDONLY|O_WRONLY|O_TRUNC);
    if(fd1==-1)
        error_handling("copy() error!");
    if(write(fd1,buf,sizeof(buf))==-1)
        error_handling("write() error!");
    close(fd);
    close(fd1);
    return 0;
}

void error_handling(char* message)
{
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```



## 2.1 套接字协议及其数据传输特性
1. 协议是为了完成数据交换而定好的约定。
2. 创建套接字
```
#include<sys/socket.h>

int socket(int domain,int type,int protocol);//成功返回文件描述符，失败返回1
```
* domain:套接字中使用的protocol family信息
* type:套接字数据传输类型信息
* protocol：计算机间通信使用的协议信息
3. 协议族，通常使用的是PF_INET对应的IPv4互联网协议族。
4. 套接字类型，指套接字的数据传输方式即上面函数的第二个参数，一般PF_INET协议族章存在多
种数据传输方式，所以需要做出选择。
* 面向连接的套接字(SOCK_STREAM)，特点是传输过程中数据不会消失，按序传输数据，传输的数据
不存在数据边界。套接字内部有缓冲区，可以调节两端的传输。这种套接字还是一一对应的。
* 面向消息的套接字(SOCK_DGRAM)，强调快速传输而非传输顺序，传输的数据可能丢失也可能损毁，
传输的数据有数据边界(指的是如果传输者分两次传输数据，那么接收者也必须按两次接受)，限制每
次传输的数据大小。
5. 协议的最终选择，即对应上面函数的第三个参数。一般前两个参数就可以决定套接字，所以大部分
情况第三个参数为0，但是如果同一个protocol family中存在多个数据传输方式相同的协议，那么
第三个参数就有意义了。
```
int tcp_socket=socket(PF_INT,SOCK_STREAM,IPPROTO_TCP);
上面即创建IPv4族中面向连接的套接字，即TCP套接字
int udp_socket=socket(PF_INT,SOCK_DGRAM,IPPROTO_UDP);
上面即创建IPv4族中面向消息的套接字，即UDP套接字
```


# 地址族与数据序列
## 3.1 分配给套接字的IP地址与端口号
+ 创建好了基于协议的套接字之后，就要给套接字分配IP地址和端口号了。端口号是为了区分程序
中创建的套接字而分配给套接字的序号。
+ 网络地址：IPv4，IPv6地址
+ 网络地址分类与主机地址边界。
+ 计算机中一般都有NIC，即网络接口卡。操作系统会负责讲传递给计算机的数据适当的分配给套接
字。通过nic接受的数据有端口号，操作系统就是参考这个端口号把数据传输给相应端口的套接字。
## 3.2 地址信息的表示
+ 表示IPv4地址的结构体
```
struct sockaddr_in{
  sa_family_t sin_family; //地址族，即v4,v6。
  uint16_t sin_port; //16位tcp/udp端口号
  struct in_addr sin_addr; //32位IP地址
  char sin_zero[8];//不使用
};

struct in_addr{
  In_addr_t s_addr; //32位IPv4地址
};
```
+ 结构体sockaddr_in的成员分析：sin_family(AF_INT:ipv4,AF_INET6:ipv6,AF_LOCAL:unix
local),sin_port,sin_addr,sin_zero(没有特殊含义，为了对齐其他结构体)
```
struct sockaddr_in serv_addr;
...
if(bind(serv_sock,(struct sockaddr*) &serv_addr,sizeof(serv_addr))==-1){
  ...
}
...
```
可以看到bind函数需要的时sockaddr结构体
```
struct sockaddr{
  sa_family_t sin_family;
  char sa_data[14];//地址信息
};
sa_data中保存地址信息中的IP地址和端口号，剩余部分应该填充0。为了方便所以我们实际使用的
是sockaddr_in,所以需要进行一次类型转换，这也是为什么我们需要在sockaddr_in中使用对齐字
符的含义。
```
## 3.3 网络字节序与地址变换
+ 字节序与网络字节序：大端序(高位字节放在低位地址)，小端序(高位字节放在高位地址)。目前
Intel系列的CPU以小端序方式保存数据，CPU保存数据的格式称为主机字节序。为了调节计算机网络
中不同主机的格式问题，我们在通过网络传输数据的时候有一个统一约定，就是网络字节序统一位大
端序。
+ 字节序转换：有一些函数完成这些功能，比如htons(h代表主机字节序，to,n代表网络字节序，s
代表short类型数据)，即将short类型数据从主机序转化为网络序。上面sockaddr_in中的sin_port
,sin_addr全部都是以网络字节序保存的。
## 3.4 网络地址的初始化与分配
+ 将字符串信息转换为网络字节序的整数型：有两个函数可以将字符串形式的IP地址转换为32位整数
型数据。即in_addr_t inet_addr(const char* string);
+ 网络地址初始化，综合上面的，常见的网络地址信息初始化方法如下
```
struct sockaddr_in addr;
char* serv_ip ="211.217.168.13";
char* serv_port="9190";
memset(&addr,0,sizeof(addr));
addr.sin_family=AF_INT;
addr.sin_addr.s_addr=inet_addr(serv_ip);
addr.sin_port=htos(atoi(serv_port));
上面的代码即初始化了sockaddr_in结构体
```
+ 客户端地址信息初始化：上面的网络地址信息初始化主要针对服务器端而非客户端。给套接字分配
IP地址和端口号主要做下面的事情(请把进入IP211.217.168.13,9190端口的数据传给我)。而客户端
主要是连接请求，即(请连接到IP211.217.168.13,9190端口)。服务器端准备工作主要由bind函数
完成，而客户端通过connect函数完成。客户端声明sockaddr_in结构体，并且初始化为要与之连接
的服务器端套接字的Ip和端口号，然后调用connect函数。
+ INADDR_ANY：服务器端可以利用这个常数来简化初始化地址信息
```
struct sockaddr_in addr;
char* serv_port="9190";
memset(&addr,0,sizeof(addr));
addr.sin_family=AF_INT;
addr.sin_addr.s_addr=htonl(INADDR_ANY);
addr.sin_port=htos(atoi(serv_port));
```
这个常数可以自动获取运行于服务器端的计算机IP地址。
一台计算机可以分配多个IP地址，实际IP地址的个数于计算机中安装的NIC数量相等。
+ 第一章中的hello_server.c,hello_client.c运行过程
+ 向套接字分配网络地址
```
#include<sys/socket.h>

int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
如果这个函数调用成功，那么就会将第二个参数中的地址信息分配给第一个参数对应的套接字(即
一个文件描述符)。
```
## 3.6 习题
(7)因为sockaddr_in是专门为IPv4建立的，而sockaddr并不是专门为IPv4创立的。



# 基于TCP的服务器端/客户端(1)
