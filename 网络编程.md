## 网络编程和套接字
1. 创建一个套接字
   ```
   int socket(int domain,int type,int protocol);
   ```
2. 创建套接字分配地址信息(ip地址和端口号)
   ```
   int  bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
   ```
3. 将套接字转化为可接受连接的状态
   ```
   int listen(int sockfd,int backlog);
   ```
4. 如果有人为了完成数据传输而请求连接
   ```
   int accept(int sockfd,struct sockaddr* addr,socklen_t* addrlen);
   ```
5. 即分为四步：调用socket函数创建套接字，调用bind函数分配ip地址和端口号，调用listen
   函数转为可接受请求状态，调用accept函数受理连接请求。
## 基于Linux的文件操作
1. 在Linux上，socket被认为是文件的一种
2. 文件描述符：是系统自动分配给文件或者套接字的整数，只是一个为了称呼的方便取得别名，
在Windows中被称为句柄。   

    | 文件描述符 | 对象 |
    |- |- |
    | 0| standard input|
    | 1| standard output|
    | 2| Standard error |
3. Linux上的文件或者套接字操作
   ```
   打开文件
   int open(const char* path,int flag);
   flag为文件打开的模式即读写或者文件操作模式
   关闭文件或者套接字
   int close(int fd);
   将数据写入文件或者传递数据
   ssize_t write(int fd,const void* buf,size_t nbytes);
   读取文件中数据或者接受数据
   ssize_t read(int fd,void* buf,size_t nbytes);
   ssize_t = signed int, size_t = unsigned int，其实它们都是通过typedef声明的基本数
   据类型取的别名而已。
   为什么要取别名呢？因为过去是16位系统，int是16位的，根据时代的变化，基本数据类型的形
   式也会变化。取了别名以后，以后修改的话，只需要修改typedef声明即可，可以减少代码改动
   ```
## 基于Windows平台的实现
1. Windows套接字大部分是参考BSD系列UNIX套接字设计的，所以很多地方都跟Linux套接字类似。
因此，只需要更改Linux环境下编好的一部分网络程序内容，就能再Windows平台下运行。大多数服
务器端都是在Linux系列的操作系统中开发的，而客服端则是在Windows平台上开发的。
2.
   ```
   Winsock数据传输函数
   int send(SOCKET s,const char* buf,int len,int flags);
   winsock数据接受函数
   int recv(SOCKET s,const char* buf,int len,int flags);
   ```
3. Windows与Linux上的套接字再一个区别是：Windows上需要先对Winsock库进行初始化，最后退
出还要注销Winsock相关库。
   ```
   int main(int  argc, char *argv[])
   {
      WSADATA wsaData;
      ...
      if(WSAStartup(MAKEWORD(1,2), &wsaData) != 0)
          ErrorHandling("WSAStartup() error!");
      ...
      return 0;
   }
   退出的时候需要释放Winsock库
   int WSACleanup(void);//返回0成功
   ```
## 习题
1.底层文件IO函数与ANSI标准定义的文件IO函数有什么区别
  通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，
  坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。
  先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。
  文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和
  管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。
2. 利用底层文件IO编写文件复制程序
```
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>
#define BUF_SIZE 100

void error_handling(char* message);

int main(void)
{
    char buf[BUF_SIZE];
    int fd=open("data.txt",O_RDONLY);
    if(fd==-1){
        error_handling("open() error!");
    }
    if(read(fd,buf,sizeof(buf))==-1)
        error_handling("read() error!");
    printf("file data: %s",buf);
    int fd1=open("data_copy.txt",O_CREAT|O_RDONLY|O_WRONLY|O_TRUNC);
    if(fd1==-1)
        error_handling("copy() error!");
    if(write(fd1,buf,sizeof(buf))==-1)
        error_handling("write() error!");
    close(fd);
    close(fd1);
    return 0;
}

void error_handling(char* message)
{
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```



## 2.1 套接字协议及其数据传输特性
1. 协议是为了完成数据交换而定好的约定。
2. 创建套接字
```
#include<sys/socket.h>

int socket(int domain,int type,int protocol);//成功返回文件描述符，失败返回1
```
* domain:套接字中使用的protocol family信息
* type:套接字数据传输类型信息
* protocol：计算机间通信使用的协议信息
3. 协议族，通常使用的是PF_INET对应的IPv4互联网协议族。
4. 套接字类型，指套接字的数据传输方式即上面函数的第二个参数，一般PF_INET协议族章存在多
种数据传输方式，所以需要做出选择。
* 面向连接的套接字(SOCK_STREAM)，特点是传输过程中数据不会消失，按序传输数据，传输的数据
不存在数据边界。套接字内部有缓冲区，可以调节两端的传输。这种套接字还是一一对应的。
* 面向消息的套接字(SOCK_DGRAM)，强调快速传输而非传输顺序，传输的数据可能丢失也可能损毁，
传输的数据有数据边界(指的是如果传输者分两次传输数据，那么接收者也必须按两次接受)，限制每
次传输的数据大小。
5. 协议的最终选择，即对应上面函数的第三个参数。一般前两个参数就可以决定套接字，所以大部分
情况第三个参数为0，但是如果同一个protocol family中存在多个数据传输方式相同的协议，那么
第三个参数就有意义了。
```
int tcp_socket=socket(PF_INT,SOCK_STREAM,IPPROTO_TCP);
上面即创建IPv4族中面向连接的套接字，即TCP套接字
int udp_socket=socket(PF_INT,SOCK_DGRAM,IPPROTO_UDP);
上面即创建IPv4族中面向消息的套接字，即UDP套接字
```


# 地址族与数据序列
## 3.1 分配给套接字的IP地址与端口号
+ 创建好了基于协议的套接字之后，就要给套接字分配IP地址和端口号了。端口号是为了区分程序
中创建的套接字而分配给套接字的序号。
+ 网络地址：IPv4，IPv6地址
+ 网络地址分类与主机地址边界。
+ 计算机中一般都有NIC，即网络接口卡。操作系统会负责讲传递给计算机的数据适当的分配给套接
字。通过nic接受的数据有端口号，操作系统就是参考这个端口号把数据传输给相应端口的套接字。
## 3.2 地址信息的表示
+ 表示IPv4地址的结构体
```
struct sockaddr_in{
  sa_family_t sin_family; //地址族，即v4,v6。
  uint16_t sin_port; //16位tcp/udp端口号
  struct in_addr sin_addr; //32位IP地址
  char sin_zero[8];//不使用
};

struct in_addr{
  In_addr_t s_addr; //32位IPv4地址
};
```
+ 结构体sockaddr_in的成员分析：sin_family(AF_INT:ipv4,AF_INET6:ipv6,AF_LOCAL:unix
local),sin_port,sin_addr,sin_zero(没有特殊含义，为了对齐其他结构体)
```
struct sockaddr_in serv_addr;
...
if(bind(serv_sock,(struct sockaddr*) &serv_addr,sizeof(serv_addr))==-1){
  ...
}
...
```
可以看到bind函数需要的时sockaddr结构体
```
struct sockaddr{
  sa_family_t sin_family;
  char sa_data[14];//地址信息
};
sa_data中保存地址信息中的IP地址和端口号，剩余部分应该填充0。为了方便所以我们实际使用的
是sockaddr_in,所以需要进行一次类型转换，这也是为什么我们需要在sockaddr_in中使用对齐字
符的含义。
```
## 3.3 网络字节序与地址变换
+ 字节序与网络字节序：大端序(高位字节放在低位地址)，小端序(高位字节放在高位地址)。目前
Intel系列的CPU以小端序方式保存数据，CPU保存数据的格式称为主机字节序。为了调节计算机网络
中不同主机的格式问题，我们在通过网络传输数据的时候有一个统一约定，就是网络字节序统一位大
端序。
+ 字节序转换：有一些函数完成这些功能，比如htons(h代表主机字节序，to,n代表网络字节序，s
代表short类型数据)，即将short类型数据从主机序转化为网络序。上面sockaddr_in中的sin_port
,sin_addr全部都是以网络字节序保存的。
## 3.4 网络地址的初始化与分配
+ 将字符串信息转换为网络字节序的整数型：有两个函数可以将字符串形式的IP地址转换为32位整数
型数据。即in_addr_t inet_addr(const char* string);
+ 网络地址初始化，综合上面的，常见的网络地址信息初始化方法如下
```
struct sockaddr_in addr;
char* serv_ip ="211.217.168.13";
char* serv_port="9190";
memset(&addr,0,sizeof(addr));
addr.sin_family=AF_INT;
addr.sin_addr.s_addr=inet_addr(serv_ip);
addr.sin_port=htos(atoi(serv_port));
上面的代码即初始化了sockaddr_in结构体
```
+ 客户端地址信息初始化：上面的网络地址信息初始化主要针对服务器端而非客户端。给套接字分配
IP地址和端口号主要做下面的事情(请把进入IP211.217.168.13,9190端口的数据传给我)。而客户端
主要是连接请求，即(请连接到IP211.217.168.13,9190端口)。服务器端准备工作主要由bind函数
完成，而客户端通过connect函数完成。客户端声明sockaddr_in结构体，并且初始化为要与之连接
的服务器端套接字的Ip和端口号，然后调用connect函数。
+ INADDR_ANY：服务器端可以利用这个常数来简化初始化地址信息
```
struct sockaddr_in addr;
char* serv_port="9190";
memset(&addr,0,sizeof(addr));
addr.sin_family=AF_INT;
addr.sin_addr.s_addr=htonl(INADDR_ANY);
addr.sin_port=htos(atoi(serv_port));
```
这个常数可以自动获取运行于服务器端的计算机IP地址。
一台计算机可以分配多个IP地址，实际IP地址的个数于计算机中安装的NIC数量相等。
+ 第一章中的hello_server.c,hello_client.c运行过程
+ 向套接字分配网络地址
```
#include<sys/socket.h>

int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
如果这个函数调用成功，那么就会将第二个参数中的地址信息分配给第一个参数对应的套接字(即
一个文件描述符)。
```
## 3.6 习题
(7)因为sockaddr_in是专门为IPv4建立的，而sockaddr并不是专门为IPv4创立的。



# 基于TCP的服务器端/客户端(1)
## 4.1 理解TCP和UDP
+ TCP/IP协议栈：(应用层)->(TCP/UDP)->(IP层)->(链路层)。
+ TCP/IP协议的诞生背景：NIC即网卡遵循链路层的协议标准。
+ IP:IP协议无法应对数据错误。
+ TCP/UDP：根据IP协议解决的路径选择问题，以此路径信息为基础完成数据传输。TCP对于不可靠
的IP协议赋予可靠性。
+ 应用层：网络编程的大部分内容就是设计并实现应用层协议。
## 4.2 实现基于TCP的服务器端和客户端
+ TCP服务器端的默认函数调用顺序
```
socket()->bind()->listen()等待连接请求状态->accept()允许交换->read()/write()->
close()
```
+ 进入等待连接请求状态
```
#include<sys/socket.h>

int listen(int sock,int backlog);//成功返回0，失败返回-1
backlog为连接请求等待队列的长度。
```
+ 受理客户端连接请求：
```
#include<sys/socket.h>

int accept(int sock,struct sockaddr* addr,socklen_t* addrlen);
//成功返回创建的套接字的文件描述符，否则返回-1
sock:服务器套接字的fd
addr:客户端地址信息
这个函数产生用于数据I/O的套接字。
```
+ TCP客户端的默认函数调用顺序
```
socket()->connect()(请求连接)->read()/write()->close()
```
服务器端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。
```
#include<sys/socket.h>

int connect(int sock,struct sockaddr* servaddr,socklen_t addrlen);
sock:客户端套接字fd
servaddr:保存目标服务器端地址信息
```
需要注意的是，客户端的IP地址和端口在调用connect的时候自动分配，无需调用标记的bind函数
进行分配。
+ 基于TCP的服务器端/客户端函数调用关系:客户端只能等到服务器端调用listen函数后才能调用
connect函数。客户端调用connect函数前，服务器端可能率先调用accept函数。但是，服务器端
在调用accept函数后进入阻塞状态，直到客户端调用connect函数。
## 4.3 实现迭代服务器端/客户端
+ 实现迭代服务器端：如果想受理多个客户端连接请求，可以插入循环语句反复调用accept函数。
+ 迭代回声服务器端/客户端：在循环处理多个连接请求的时候，读写数据必须要考虑tcp协议的没有
数据边界的特征，即客户端和服务器端执行的读写操作次数可能是不一样的，因为之间有个读写缓存。


# 基于TCP的服务器端和客户端
## 5.1 回声客户端的完美实现
+  回声客户端的问题解决办法：只需要加入一个限制条件，即接受数据的大小应该和传输过去的相
同即可。
+ 回声客户端可以提前直到接受的数据长度，但是一般情况下，这是不可能的。那么就可以定义应
用层协议。看如下代码
```
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<string.h>
using namespace std;

int main()
{
	/***int num=455;
	int* i=&num;
	char* c=(char*)(&num);
	cout << i << endl;
	cout << c << endl;
	return 0;***/
	char buf[12];
	int num1=513;
	int num2=514;
	int num3=515;
	memcpy((int*)&buf[0],&num1,sizeof(int));
	memcpy((int*)&buf[4],&num2,sizeof(int));
	memcpy((int*)&buf[8],&num3,sizeof(int));
	for(int i=0;i<12;i++){
		cout << i << ": " << int(buf[i]) << endl;
	}
	int* buf1=(int*)buf;
	cout << *buf1 << endl;
	cout << *(buf1+1) << endl;
	cout << *(buf1+2) << endl;
	return 0;
}
上面的代码是用一个char数据存储int数据。
&num1取num1的地址，由于num1是int型，&buf[0]是取char数组第一个位置的地址，为了在char
数组中保存int值，需要告诉编译器buf在他的第一个位置取4个字节以保存num1的值。所以memcpy
把num1变量地址所保存的值(513)拷贝到buf数组的0，1，2，3位置，因为int占4个字节。
memcpy第一个参数为待拷贝的地址，第二个参数为被拷贝的数据的地址。第三个参数为拷贝的字节数
这里可以把他的第一个参数的(int*)去掉，因为他的第三个参数已经告诉了待拷贝的数据要占的字节
数。去掉不去掉没什么影响。如果要取出buf中的值，并且取出的要是int值，需要将buf数组转化为
int型的指针，这样取值的时候编译器会知道这个地址处的值为int值，所以要取四个字节。然后就
取出了int值。
```
## 5.2 TCP原理
+ TCP套接字中的IO缓冲：IO缓存在每个套接字中单独存在，即使关闭套接字也会继续传递输出缓存
中遗留的数据，关闭套接字将丢失输入缓冲中的数据。因为缓冲有大小，所以TCP协议中的滑动窗口
协议会控制数据流的大小。
+ TCP的内部工作原理1：于对方套接字的连接。套接字以全双工方式工作，即可以双向传递数据。
三次握手。书本103
+ TCP的内部工作原理2：与对方主机的数据交换。
+ TCP的内部工作原理3：断开与套接字的连接。四次握手。书本106页


# 基于UDP的服务器端/客户端
## 6.1 理解UDP
+ UDP套接字的特点：不可靠的数据传输服务。UDP虽然不可靠，但是很快。TCP只有在交换的数据量
很大的情况下，传输速率才会接近UDP的传输速率。
+ UDP内部工作原理：UDP最重要的作用就是将传到主机的数据包交付给最终的UDP套接字。
+ UDP的高效使用：TCP比UDP慢主要因为数据收发前后的连接设置及清除过程，和收发数据工程中
因为保证可靠性而添加的流控制。所以当收发的数据量小并且需要频繁连接的时候，UDP比TCP更加
高效。
## 6.2 实现基于UDP的客户端和服务器端
+ UDP中服务器端和客户端没有连接。所以不必调用listen和accept函数。
+ UDP服务器端和客户端都只需一个套接字：TCP中，套接字之间是一一对应的，除了守门的服务器
套接字外，如果要向10个客户端提供服务，那么还需要10个服务器端套接字。
+ 基于UDP的数据IO函数：创建好TCP套接字后，传输数据无需再添加地址信息，因为TCP套接字将
保持与对方套接字的连接。即TCP套接字知道目标地址信息。
```
#include<sys/socket.h>

ssize_t sendto(int sock,void* buff,size_t nbytes,int flags,struct sockaddr* to,
  socklen_t addrlen);
sock:用于传输数据的udp套接字fd
buff:保存带传输数据的缓冲地址值
nbytes:待传输数据长度
to:目标地址信息
addrlen:目标地址信息的长度

ssize_t recvfrom(int sock,void* buff,size_t nbytes,int flags,struct sockaddr* to,
  socklen_t addrlen);
接受信息的函数，与上面的对应
```
+ 基于UDP的回声服务器端和客户端：套接字其实就是提供了两个缓冲空间，即输入缓冲和输出缓冲。
+ UDP客户端套接字的地址分配：TCP的客户端在调用connect函数的时候完成客户端套接字的地址
分配，而UDP程序中，首次调用sendto函数时给相应的套接字自动分配IP和端口。端口号使用尚未
使用的任意端口号。
## 6.3 UDP的数据传输特性和调用connect函数
+ 存在数据边界的UDP套接字：所以传输中调用io函数的次数非常重要。即输入函数的调用次数应该
和输出函数的调用次数一样。
+ 已连接UDP套接字和未连接UDP套接字：也可以使用connect函数将UDP套接字变为长连接的套接字
，这样可以在需要多次传输数据的时候节省时间。此时UDP也可以使用read和write函数。


# 优雅的断开套接字连接
## 7.1 基于TCP的半关闭
+ 单方面断开连接带来的问题：即可以传输数据但是无法接受，或者可以接受数据但是无法传输。
+ 套接字和流：
+ 针对优雅断开的shutdown函数：
```
#include<sys/socket.h>

int shutdown(int sock,int howto);
//成功返回0，失败返回1
sock:需要断开的套接字fd
howto:传递断开方式信息
SHUT_RD：断开输入流
SHUT_WR: 断开输出流
SHUT_RDWR： 同时断开io流
```
+ 为何需要半关闭：
+ 基于半关闭的文件传输程序：


# 域名及网络地址
## 8.1 域名系统
+ DNS是对IP地址和域名进行相互转换的系统，核心是DNS服务器
+ DNS服务器：
```
ping www.google.com
即可以知道某一个域名对应的IP地址
nslookup
可以知道自己计算机中注册的默认DNS服务器地址。DNS就是层次化管理的一种分布式数据库系统。
```
## 8.2 IP地址和域名之间的转换
+ 程序中有必要使用域名么：因为IP地址比域名发生变更的概率要高，所以利用IP地址编写程序并非
上策。所以程序中需要IP地址和域名之间的转换函数。
+ 利用域名获取IP地址：利用以下函数可以通过传递字符串格式的域名获取IP地址
```
#include<netdb.h>

struct hostent* gethostbyname(const char* hostname);
//成功返回hostent结构体地址，失败返回null指针

struct hostent{
  char* h_name;
  char** h_aliases;
  int h_addrtype;
  int h_length;
  char** h_addr_list;
};

h_aliases:同一IP可以绑定多个域名。
h_addr_list:以整数形式保存域名对应的IP地址。用户较多的网站可能分配多个IP给同一个域名，
利用多个服务器进行负载均衡。
```
+ 利用IP地址获取域名
```
struct hostent* gethostbyaddr(const char* addr,socklen_t len,int family);
//成功返回hostent结构体变量地址值，失败返回null指针
addr:含有IP地址信息的in_addr结构体指针
len:第一个参数的地址信息的字节数，IPv4为4，IPv6为6
family:地址族信息，AF_INET为IPv4,IPv6为AF_INET6
```


# 套接字的多种可选项
## 9.1 套接字可选项和IO缓冲大小
+ 套接字多种可选项：
+ getsockopt&setsockopt：可选项的读取和设置通过下面两个函数完成
```
#include<sys/socket.h>

int getsockopt(int sock,int level,int optname,void *optval,socklen_t *optlen);
//成功返回0，失败返回1
level：要查看的可选项的协议层
optname:要查看的可选项名
optval:保存查看结果的缓冲地址值
optlen:向第四个参数optval传递的缓冲大小。

int setsockopt(int sock,int level,int optname,const void *optval,socklen_t optle
  n);
```
套接字类型只在创建时决定，以后不能再改变。
+ SO_SNDBUF&SO_RCVBUF:这两个选项可以读取当前IO缓冲大小。也可以进行更改。
## 9.2 SO_REUSEADDR
+ 发生地址分配错误：在TCP中，我们可以通过服务器端和客户端关闭连接，如果在客户端通过CTRL
+C，不会出现问题，但是如果向服务器端控制台输入CTRL+C可能会出现之后用一端口号重新运行服务
器端的时候出现bind() error。需要等一段时间后，才可以重新运行服务器端。这两种方式的区别
就是由那个端先传输FIN消息。
+ Time-wait状态：如果服务器端使用CTRL+C中断连接，即服务器端先发送FIN消息，经过四次握手
后就会断开连接，但是先发送FIN消息的端会经过一段time-wait时间才会消除套接字，所以这个时
候重新运行，bind()函数会发送错误。因为相应的端口还在使用之中。其实如果客户端先发送FIN也
会进入time-wait。但是因为客户端的端口是任意指定的，所以不会发生影响。
+ 地址再分配：Time-wait状态很重要，但是当服务器a的最后的ack消息丢失后，如果网络状态不好
，会导致一直重传。如果我们向尽快重启服务器然后继续提供服务，那么就需要将套接字中的SO_RE
USEADDR设置为真，可以在time-wait时间内分配套接字端口号。
## 9.3 TCP_NODELAY
+ Nagel算法:为防止数据包过多而发生的网络过载。应用于TCP层。可以描述为：只有收到前一数据
的ACK消息时，Nagle算法才发送下一数据。不适用Nagle算法将对网络流量产生负面影响，导致数据
包过多。一般情况下，不应该禁用Nagel算法。但是也有特殊情况。
+ 禁用Nagel算法：传输大文件数据的时候应该禁用Nagel算法。将套接字可选项TCP_NODELAY改为
1即可禁用Nagel算法。


# 多进程服务器端
## 10.1 进程概念及应用
